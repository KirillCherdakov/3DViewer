<h1 id="3dviewer-v1-0">3DViewer v1.0</h1>
<blockquote>
<p>При старте работы над проектом просим тебя постараться хронометрировать время работы над проектом.
По завершении работы над проектом, пожалуйста, ответь на два вопроса <a href="https://forms.gle/51aADrXJGHYH9jEi6">в этом опросе</a></p>
</blockquote>
<p>Разработать программу 3DViewer v1.0.</p>
<h2 id="contents">Contents</h2>
<ol>
<li><a href="#preamble">Preamble</a></li>
<li><a href="#chapter-i">Chapter I</a> \
 1.1. <a href="#introduction">Introduction</a></li>
<li><a href="#chapter-ii">Chapter II</a> \
 2.1. <a href="#information">Information</a></li>
<li><a href="#chapter-iii">Chapter III</a> \
 3.1. <a href="#part-1-3dviewer">Part 1</a> \
 3.2. <a href="#part-2-дополнительно-настройки">Part 2</a> \
 3.3. <a href="#part-3-дополнительно-запись">Part 3</a>     </li>
</ol>
<h2 id="preamble">Preamble</h2>
<p><img src="misc/images/3dviewer.png" alt="3DViewer"></p>
<p>Где-то около кулера с водой в 1990-ом году:</p>
<p><em>-- Мы не можем сделать мультфильм про животных.</em></p>
<p><em>- Почему? Черт возьми, Джон, твоя «Оловянная игрушка» произвела фурор! Ты представь, что будет, когда мир увидит что-нибудь вроде «Ста одного далматинца», но только в 3D!</em></p>
<p><em>-- В этом-то вся и проблема. Вычислительных мощностей пока недостаточно для того, чтобы анимировать сложные объекты. Животным придется подождать, смоделировать их шерсть не представляется возможным. Либо это будет мультфильм про лысых животных. Нужно выждать несколько лет, пока закон Мура отработает свое.</em></p>
<p><em>- Ну хорошо, а что насчет людей? Почему мы не можем сделать мультик про людей?</em></p>
<p><em>-- Можем, но разве что ужастик, потому что их лица будут выглядеть примерно так же, как сейчас выглядит твое, пытающееся убедить меня совершить роковую ошибку.</em></p>
<p>Ты понял, что аргументы Лассетера слишком убедительны, чтобы с ним спорить.</p>
<p><em>- Ладно, допустим, ты прав. Но какой тогда мультфильм нам делать?</em></p>
<p><em>- Все просто, друг мой. Это будет мультфильм про игрушки, как короткометражка, что принесла нам «Оскар». Природная форма игрушек отлично подойдет под low-полигональные 3D-модели, которые мы способны анимировать. И скудная мимика не станет критичной, это ведь игрушки. Да и сюжетик на примете уже имеется... Оживим их! И построим сюжет на взаимоотношениях игрушек и ребенка.</em></p>
<p><em>- Звучит заманчиво!</em></p>
<p><em>-- Вот-вот. Отправляйся скорее к своей команде и займись разработкой ПО для 3D-моделирования. Если мы хотим сделать этот мультик, нам нужны свои собственные программные средства. То, что есть на рынке, позволит анимировать разве что деревянную пирамиду, да и ту в форме куба.</em></p>
<p><em>- Хорошо. Сперва займемся самым главным - экраном предпросмотра.</em></p>
<p><em>-- Удачи!</em></p>
<p>В распоряжении Pixar было более 100 компьютеров, которые занимались рендерингом 3D-сцен. Осознав потенциал таких мощностей, ты произносишь вдохновляющую речь перед своей командой, восхваляя технологии 3D-визуализации, и быстро принимаешься за работу! Планируемому мультику суждено войти в историю.</p>
<h2 id="chapter-i">Chapter I</h2>
<h2 id="introduction">Introduction</h2>
<p>В данном проекте тебе предстоит реализовать на языке программирования С программу для просмотра 3D-моделей в каркасном виде (3D Viewer). Сами модели необходимо загружать из файлов формата .obj и иметь возможность просматривать их на экране с возможностью вращения, масштабирования и перемещения.</p>
<h2 id="chapter-ii">Chapter II</h2>
<h2 id="information">Information</h2>
<p>Каркасная модель - модель объекта в трёхмерной графике, представляющая собой совокупность вершин и рёбер, которая определяет форму отображаемого многогранного объекта в трехмерном пространстве.</p>
<h3 id="-">Напоминание о структурном подходе</h3>
<p>В основе структурного подхода к программированию лежит два базовых принципа:</p>
<ul>
<li>принцип «разделяй и властвуй» (декомпозиция) - принцип решения сложных проблем путем их разбиения на множество меньших независимых задач, простых для понимания и решения. Причем при решении небольших задач исключается дублирование кода, а сами их решения при необходимости переиспользуются;</li>
<li>принцип иерархического упорядочивания - принцип организации составных частей проблемы в иерархические древовидные структуры с добавлением новых деталей на каждом уровне (от верхнего уровня с одной точкой входа, до нижних с конкретными структурами данных и реализациями). То естьб на одном и том же уровне не должно быть выполнения вычислений и операций ввода-вывода.</li>
</ul>
<p>Таким образом, при использовании структурного стиля получается, что программа строится в виде «слоеного пирога» сверху вниз. Ошибки генерируются на нижних уровнях и прокидываются на самый верх, где выводятся пользователю. </p>
<h3 id="-obj">Формат представления описаний трехмерных объектов .obj</h3>
<p>Файлы .obj - это формат файла описания геометрии, впервые разработанный компанией Wavefront Technologies. Формат файла открыт и принят многими поставщиками приложений для 3D-графики.</p>
<p>Формат файла .obj - это простой формат данных, который представляет только трехмерную геометрию, а именно положение каждой вершины, положение UV координат текстуры каждой вершины, нормали вершин и грани, которые определяют каждый многоугольник как список вершин и вершин текстуры. Координаты obj не имеют единиц измерения, но файлы obj могут содержать информацию о масштабе в удобочитаемой строке комментариев.</p>
<p>Пример файла формата .obj:</p>
<pre><code>  # Список вершин, с координатами (x, y, z[, w]), w является не обязательным и по умолчанию равен <span class="hljs-number">1.0</span>
  v <span class="hljs-number">0.123</span> <span class="hljs-number">0.234</span> <span class="hljs-number">0.345</span> <span class="hljs-number">1.0</span>
  v ...
  ...
  # Текстурные координаты (u, v[, w]), w является не обязательным и по умолчанию <span class="hljs-number">0</span>
  vt <span class="hljs-number">0.500</span> <span class="hljs-number">-1.352</span> [<span class="hljs-number">0.234</span>]
  vt ...
  ...
  # Нормали (x, y, z)
  vn <span class="hljs-number">0.707</span> <span class="hljs-number">0.000</span> <span class="hljs-number">0.707</span>
  vn ...
  ...
  # Параметры вершин в пространстве (u[, v][, w])
  vp <span class="hljs-number">0.310000</span> <span class="hljs-number">3.210000</span> <span class="hljs-number">2.100000</span>
  vp ...
  ...
  # Определения поверхности (сторон)
  f v1 v2 v3
  f ...
  ...
  # Группа
  g Group1
  ...
  # Объект
  o Object1
</code></pre><p>В данном проекте тебе будет достаточно реализовать поддержку списка вершин и поверхностей. Все остальное не является обязательным.</p>
<h3 id="-">Аффинные преобразования</h3>
<p>В данном разделе будут описаны базовые аффинные преобразования (перемещение, поворот, масштабирование) на плоскости на примере двумерных объектов (изображений). Аналогичным образом можно использовать аффинные преобразования и в случае трехмерного пространства.</p>
<p>Аффинное преобразование - отображение плоскости или пространства в себя, при котором параллельные прямые переходят в параллельные прямые, пересекающиеся — в пересекающиеся, скрещивающиеся — в скрещивающиеся. \
Преобразование плоскости называется аффинным, если оно взаимно однозначно и образом любой прямой является прямая. Преобразование (отображение) называется взаимно однозначным (биективным), если оно переводит разные точки в разные, и в каждую точку переходит какая-то точка.</p>
<p>С алгебраической точки зрения, аффинное преобразование - это преобразование вида <em>f(x) = M * x + v</em>, где <em>M</em> - некая обратимая матрица, а <em>v</em> - какое-то значение.</p>
<p>Свойства аффинных преобразований:</p>
<ul>
<li>Композиция аффинных преобразований есть снова аффинное преобразование;</li>
<li>Преобразование, обратное к аффинному, есть снова аффинное преобразование;</li>
<li>Отношение площадей сохраняется;</li>
<li>Отношение длин отрезков на прямой сохраняется.</li>
</ul>
<h4 id="-">Перемещение</h4>
<p>Матрица перемещения в однородных двумерных координатах:</p>
<pre><code><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> a
<span class="hljs-symbol">0 </span><span class="hljs-number">1</span> b
<span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span>
</code></pre><p>где <em>a</em> и <em>b</em> - величины по <em>x</em> и <em>y</em>, на которые необходимо переместить исходную точку. Таким образом, чтобы переместить точку необходимо умножить матрицу перемещения на нее:</p>
<pre><code>x1     <span class="hljs-number">1</span> <span class="hljs-number">0</span> a     x 
y1  =  <span class="hljs-number">0</span> <span class="hljs-number">1</span> b  *  y
<span class="hljs-number">1</span>      <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>     <span class="hljs-number">1</span>
</code></pre><p>где <em>x</em> и <em>y</em> - исходные координаты точки, а <em>x1</em> и <em>y1</em> - полученные координаты новой точки после перемещения.</p>
<h4 id="-">Поворот</h4>
<p>Матрица поворота по часовой стрелке в однородных двумерных координатах:</p>
<pre><code>cos(<span class="hljs-name">a</span>)  sin(<span class="hljs-name">a</span>) <span class="hljs-number">0</span>
-sin(<span class="hljs-name">a</span>) cos(<span class="hljs-name">a</span>) <span class="hljs-number">0</span>
<span class="hljs-number">0</span>       <span class="hljs-number">0</span>      <span class="hljs-number">1</span>
</code></pre><p>где <em>a</em> - угол поворота в двумерном пространстве. Для получения координат новой точки необходимо так же, как и матрицу перемещения, перемножить матрицу поворота на исходную точку:</p>
<pre><code>x1     cos(<span class="hljs-name">a</span>)  sin(<span class="hljs-name">a</span>) <span class="hljs-number">0</span>     x 
y1  =  -sin(<span class="hljs-name">a</span>) cos(<span class="hljs-name">a</span>) <span class="hljs-number">0</span>  *  y
<span class="hljs-number">1</span>      <span class="hljs-number">0</span>       <span class="hljs-number">0</span>      <span class="hljs-number">1</span>     <span class="hljs-number">1</span>
</code></pre><h4 id="-">Масштабирование</h4>
<p>Матрица масштабирования в однородных двумерных координатах:</p>
<pre><code>a <span class="hljs-number">0</span> <span class="hljs-number">0</span>
<span class="hljs-number">0</span> b <span class="hljs-number">0</span>
<span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>
</code></pre><p>где <em>a</em> и <em>b</em> - коэффициенты масштабирования соответственно по осям OX и OY. Получение координат новой точки происходит аналогично описанным выше случаям.</p>
<h2 id="chapter-iii">Chapter III</h2>
<h2 id="part-1-3dviewer">Part 1. 3DViewer</h2>
<p>Тебе предстоит разработать программу для визуализации каркасной модели в трехмерном пространстве:</p>
<ul>
<li>Программа должна быть создана на языке С стандарта C11 с использованием компилятора gcc. Допустимо использование дополнительных библиотек и модулей QT;</li>
<li>Код программы должен находиться в папке src;</li>
<li>Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для GNU-программ: all, install, uninstall, clean, dvi, dist, tests, gcov_report. Установка должна вестись в любой другой произвольный каталог;</li>
<li>Программа должна быть разработана в соответствии с принципами структурного программирования;</li>
<li>При написании кода необходимо придерживаться Google Style;</li>
<li>Должно быть обеспечено покрытие unit-тестами модулей, связанных с загрузкой моделей и аффинными преобразованиями;</li>
<li>В один момент времени должна быть только одна модель на экране;</li>
<li>Программа должна предоставлять возможность:<ul>
<li>Загружать каркасную модель из файла формата obj (поддержка только списка вершин и поверхностей);</li>
<li>Перемещать модель на заданное расстояние относительно осей X, Y, Z;</li>
<li>Поворачивать модель на заданный угол относительно своих осей X, Y, Z;</li>
<li>Масштабировать модель на заданное значение;</li>
</ul>
</li>
<li>В программе должен быть реализован графический пользовательский интерфейс, на базе любой GUI-библиотеки с API для C89/C99/C11 <br/><ul>
<li>For Linix: GTK+, CEF, Qt<br/>;</li>
<li>For Mac: GTK+, Nuklear, raygui, microui, libagar, libui, IUP, LCUI, CEF, Qt;</li>
</ul>
</li>
<li>Графический пользовательский интерфейс должен содержать:<ul>
<li>Кнопку для выбора файла с моделью и поле для вывода его названия;</li>
<li>Зону визуализации каркасной модели;</li>
<li>Кнопку/кнопки и поля ввода для перемещения модели;</li>
<li>Кнопку/кнопки и поля ввода для поворота модели;</li>
<li>Кнопку/кнопки и поля ввода для масштабирования модели;  </li>
<li>Информацию о загруженной модели - название файла, кол-во вершин и ребер;</li>
</ul>
</li>
<li>Программа должна корректно обрабатывать и позволять пользователю просматривать модели с деталями до 100, 1000, 10 000, 100 000, 1 000 000 вершин без зависания (зависание - это бездействие интерфейса более 0,5 секунды).</li>
</ul>
<p><em>Замечание:</em> <strong>Не загружай тяжелые файлы (&gt;10 мб) в гит.</strong></p>
<h2 id="part-2-">Part 2. Дополнительно. Настройки</h2>
<ul>
<li>Программа должна позволять настраивать тип проекции (параллельная и центральная);</li>
<li>Программа должна позволять настраивать тип (сплошная, пунктирная), цвет и толщину ребер, способ отображения (отсутствует, круг, квадрат), цвет и размер вершин;</li>
<li>Программа должна позволять выбирать цвет фона;</li>
<li><p>Настройки должны сохраняться между перезапусками программы.</p>
<h2 id="part-3-">Part 3. Дополнительно. Запись</h2>
</li>
<li><p>Программа должна позволять сохранять полученные («отрендеренные») изображения в файл в форматах bmp и jpeg;</p>
</li>
<li>Программа должна позволять по специальной кнопке записывать небольшие «скринкасты» - текущие пользовательские аффинные преобразования загруженного объекта в gif-анимацию (640x480, 10fps, 5s).</li>
</ul>
<p>💡 <a href="https://forms.yandex.ru/cloud/641815b8e010db24ff2687a4/">Нажми сюда</a><strong>, чтобы поделиться с нами обратной связью на этот проект</strong>. Это анонимно и поможет команде Продукта сделать твоё обучение лучше.</p>

